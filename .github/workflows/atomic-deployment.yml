name: Atomic Deployment Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'Phase_*.py'
      - 'artifacts_phase*/**'
      - '*.py'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        type: boolean
        default: false

env:
  PYTHON_VERSION: '3.11'
  ARTIFACTS_DIR: 'artifacts_phase2'

jobs:
  # Artifact verification and preparation
  verify-artifacts:
    runs-on: ubuntu-latest
    outputs:
      artifacts-hash: ${{ steps.hash-artifacts.outputs.hash }}
      metadata-valid: ${{ steps.verify-metadata.outputs.valid }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        # Install additional CI dependencies
        pip install jq-py pytest pytest-cov
        
    - name: Verify artifact integrity
      id: verify-metadata
      run: |
        echo "Verifying local artifacts before deployment..."
        
        if [[ ! -f "$ARTIFACTS_DIR/metadata.json" ]]; then
          echo "ERROR: metadata.json not found"
          echo "valid=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        # Use Python to verify JSON and checksums
        python << 'EOF'
        import json
        import hashlib
        import os
        import sys
        
        artifacts_dir = os.environ['ARTIFACTS_DIR']
        metadata_file = os.path.join(artifacts_dir, 'metadata.json')
        
        try:
            with open(metadata_file, 'r') as f:
                metadata = json.load(f)
            
            artifacts_manifest = metadata.get('artifacts_manifest', {})
            if not artifacts_manifest:
                print("WARNING: No artifacts_manifest in metadata.json")
                print("valid=true", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
                sys.exit(0)
            
            all_valid = True
            for filename, checksum_info in artifacts_manifest.items():
                filepath = os.path.join(artifacts_dir, filename)
                if os.path.exists(filepath):
                    # Calculate actual checksum
                    with open(filepath, 'rb') as f:
                        actual_checksum = hashlib.sha256(f.read()).hexdigest()
                    
                    # Get expected checksum
                    expected_checksum = checksum_info if isinstance(checksum_info, str) else checksum_info.get('sha256', '')
                    
                    if actual_checksum == expected_checksum:
                        print(f"‚úì {filename}: checksum verified")
                    else:
                        print(f"‚úó {filename}: checksum mismatch")
                        print(f"  Expected: {expected_checksum}")
                        print(f"  Actual:   {actual_checksum}")
                        all_valid = False
                else:
                    print(f"WARNING: {filename} not found locally")
            
            if all_valid:
                print("All artifacts verified successfully")
                print("valid=true", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
            else:
                print("Artifact verification failed")
                print("valid=false", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
                sys.exit(1)
                
        except Exception as e:
            print(f"ERROR: Failed to verify artifacts: {e}")
            print("valid=false", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
            sys.exit(1)
        EOF
        
    - name: Generate artifacts hash
      id: hash-artifacts
      run: |
        # Create hash of all artifacts for deployment tracking
        artifacts_hash=$(find $ARTIFACTS_DIR -type f -exec sha256sum {} + | sort | sha256sum | cut -d' ' -f1)
        echo "hash=$artifacts_hash" >> $GITHUB_OUTPUT
        echo "Artifacts hash: $artifacts_hash"
        
    - name: Upload artifacts for deployment
      uses: actions/upload-artifact@v4
      with:
        name: verified-artifacts-${{ steps.hash-artifacts.outputs.hash }}
        path: |
          ${{ env.ARTIFACTS_DIR }}/
          deploy_atomic.sh
          deploy_atomic.ps1
        retention-days: 30

  # Unit tests
  test:
    runs-on: ubuntu-latest
    needs: verify-artifacts
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov psutil
        
    - name: Run unit tests
      run: |
        # Run memory monitoring tests
        python test_memory_unit.py
        
        # Run other unit tests if they exist
        if ls test_*.py 1> /dev/null 2>&1; then
          pytest test_*.py -v --cov=. --cov-report=xml
        fi
        
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      if: always()
      with:
        file: ./coverage.xml
        flags: unittests

  # Staging deployment
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [verify-artifacts, test]
    if: |
      github.ref == 'refs/heads/develop' || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_target == 'staging') ||
      (github.event.inputs.force_deploy == 'true')
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download verified artifacts
      uses: actions/download-artifact@v4
      with:
        name: verified-artifacts-${{ needs.verify-artifacts.outputs.artifacts-hash }}
        path: ./
        
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts
        
    - name: Atomic deployment to staging
      env:
        DEPLOY_USER: ${{ secrets.STAGING_USER }}
        DEPLOY_HOST: ${{ secrets.STAGING_HOST }}
        DEPLOY_PATH: ${{ secrets.STAGING_PATH }}
      run: |
        chmod +x deploy_atomic.sh
        
        echo "Starting atomic deployment to staging..."
        echo "Target: $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH"
        
        # Run atomic deployment with verbose output
        ./deploy_atomic.sh deploy
        
    - name: Post-deployment verification
      env:
        DEPLOY_USER: ${{ secrets.STAGING_USER }}
        DEPLOY_HOST: ${{ secrets.STAGING_HOST }}
      run: |
        echo "Running post-deployment verification..."
        
        # Verify service is running
        ssh $DEPLOY_USER@$DEPLOY_HOST "
          echo 'Checking service status...'
          sudo systemctl status phase4-inference --no-pager || true
          
          echo 'Checking health endpoint...'
          curl -f http://localhost:9208/health || echo 'Health check failed'
          
          echo 'Checking metrics endpoint...'
          curl -s http://localhost:9208/metrics | grep -E 'phase4_(uptime|memory_rss)' || echo 'Metrics check failed'
        "
        
    - name: Notify deployment status
      if: always()
      run: |
        if [[ ${{ job.status }} == 'success' ]]; then
          echo "‚úÖ Staging deployment successful"
          echo "Artifacts hash: ${{ needs.verify-artifacts.outputs.artifacts-hash }}"
        else
          echo "‚ùå Staging deployment failed"
        fi

  # Production deployment
  deploy-production:
    runs-on: ubuntu-latest
    needs: [verify-artifacts, test, deploy-staging]
    if: |
      github.ref == 'refs/heads/main' || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_target == 'production')
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download verified artifacts
      uses: actions/download-artifact@v4
      with:
        name: verified-artifacts-${{ needs.verify-artifacts.outputs.artifacts-hash }}
        path: ./
        
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
        
    - name: Production deployment approval
      run: |
        echo "üöÄ Production deployment initiated"
        echo "Artifacts verified: ${{ needs.verify-artifacts.outputs.metadata-valid }}"
        echo "Tests passed: ${{ needs.test.result }}"
        echo "Staging deployment: ${{ needs.deploy-staging.result }}"
        
    - name: Atomic deployment to production
      env:
        DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
        DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
        DEPLOY_PATH: ${{ secrets.PRODUCTION_PATH }}
      run: |
        chmod +x deploy_atomic.sh
        
        echo "Starting atomic deployment to production..."
        echo "Target: $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH"
        
        # Production deployment with extra verification
        ./deploy_atomic.sh verify-local
        ./deploy_atomic.sh deploy
        
    - name: Production health check
      env:
        DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
        DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
      run: |
        echo "Running extended production health check..."
        
        # Wait longer for production startup
        sleep 30
        
        # Comprehensive health verification
        ssh $DEPLOY_USER@$DEPLOY_HOST "
          echo 'Production service verification:'
          
          # Service status
          sudo systemctl status phase4-inference --no-pager
          
          # Health endpoint with retries
          for i in {1..5}; do
            if curl -f http://localhost:9208/health; then
              echo 'Health check passed'
              break
            else
              echo \"Health check attempt \$i failed, retrying...\"
              sleep 10
            fi
          done
          
          # Memory monitoring check
          curl -s http://localhost:9208/metrics | grep phase4_memory || echo 'Memory metrics not available'
          
          # Process verification
          pgrep -f Phase_Four.py && echo 'Process running' || echo 'Process not found'
        "
        
    - name: Deployment summary
      if: always()
      run: |
        echo "=== Production Deployment Summary ==="
        echo "Status: ${{ job.status }}"
        echo "Artifacts Hash: ${{ needs.verify-artifacts.outputs.artifacts-hash }}"
        echo "Deployment Time: $(date -u)"
        echo "Git Commit: ${{ github.sha }}"
        echo "Git Ref: ${{ github.ref }}"
        
        if [[ ${{ job.status }} == 'success' ]]; then
          echo "üéâ Production deployment completed successfully!"
          echo "No more 'expected != actual' checksum mismatches should occur"
        else
          echo "‚ùå Production deployment failed - check logs for details"
        fi